package main

import (
	"encoding/binary"
	"encoding/hex"
	"fmt"
)

func main() {
	original := []byte{
		//Magic 4 байта
		0x41, 0xA4, 0x12, 0x21,

		//ScriptName 70 байт
		0x6B, 0x75, 0x63, 0x68, 0x65, 0x76, 0x61, 0x73, 0x6F, 0x76,
		0x2E, 0x64, 0x2F, 0x72, 0x75, 0x6E, 0x43, 0x6D, 0x64, 0x00,
		0x01, 0x00, 0x84, 0xFF, 0xEB, 0x01, 0x00, 0x0A, 0x0B, 0x0C,
		0x0D, 0x0E, 0x0F, 0x01, 0x00, 0x02, 0x03, 0xFF, 0x10, 0xFF,
		0x12, 0x13, 0x36, 0x35, 0x14, 0x0F, 0x5E, 0x00, 0x00, 0x00,
		0x00, 0x80, 0xF7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

		//ChunkNumber 4 байта
		0x01, 0x00, 0x00, 0x00,

		//PayloadSize 2 байта - здесь учитывается ScriptCrc + ScriptSize
		0x10, 0x00,
		//выше header

		//ScriptCrc + ScriptSize 8 байт после encoding
		0xBC, 0x7F, 0xDC, 0xCA, 0x60, 0xCD, 0x86, 0x8D,
		0x6F, 0x9D, 0x4D, 0x3F, 0xD5, 0x2F, 0x80, 0x4C,

		//Crc
		0x00, 0x00}

	testKey := []byte{0xA1, 0x2B, 0xC3, 0x47, 0x65, 0x64, 0x56, 0x58, 0x51, 0x03, 0x03, 0x01, 0x05, 0x16, 0x07, 0xD8, 0x1F, 0x52, 0x33, 0x4A, 0x5A, 0x63, 0x79, 0x3E, 0x54, 0x76, 0x13, 0x54, 0x45, 0x36, 0x27, 0x28}
	block := make([]byte, 8)
	for i := 0; i < len(original)/8; i++ {
		block = decrypt(testKey, original[(i*8):((i+1)*8)], 32)
		fmt.Println(hex.Dump(block))
	}
}

func decrypt(key []byte, block []byte, rounds uint32) []byte {
	var k [4]uint32
	var i uint32
	end := make([]byte, 8)
	v0 := binary.LittleEndian.Uint32(block[:4])
	v1 := binary.LittleEndian.Uint32(block[4:])

	k[0] = binary.LittleEndian.Uint32(key[:4])
	k[1] = binary.LittleEndian.Uint32(key[4:8])
	k[2] = binary.LittleEndian.Uint32(key[8:12])
	k[3] = binary.LittleEndian.Uint32(key[12:])

	delta := binary.LittleEndian.Uint32([]byte{0xb9, 0x79, 0x37, 0x9e})
	mask := binary.LittleEndian.Uint32([]byte{0xff, 0xff, 0xff, 0xff})

	sum := (delta * rounds) & mask

	for i = 0; i < rounds; i++ {
		v1 = (v1 - (((v0<<4 ^ v0>>5) + v0) ^ (sum + k[sum>>11&3]))) & mask
		sum = (sum - delta) & mask
		v0 = (v0 - (((v1<<4 ^ v1>>5) + v1) ^ (sum + k[sum&3]))) & mask
	}

	binary.LittleEndian.PutUint32(end[:4], v0)
	binary.LittleEndian.PutUint32(end[4:], v1)

	return end
}

// package main

// import "fmt"

// func main() {
// 	var a int
// 	var scanCount, err = fmt.Scan(&a)
// 	if err != nil {
// 		panic(err)
// 	}
// 	fmt.Println(scanCount)
// 	h := a / 30
// 	m := a*2 - (h * 60)
// 	fmt.Println("it is", h, "hours", m, "minutes.")
// }
